/** 백준 11403: 경로 찾기 (최단 경로/실버1)
 *
 * 다익스트라 알고리즘: '출발지:하나의 정점' -> '목적지:모든 정점'으로의 최단 경로
 * 플로이드 와샬 알고리즘: '출발지:모든 정점' -> '목적지:모든 정점'으로의 최단 경로
 * ______________________________________________________________________
 * 가중치 없는 방향 그래프 G
 * 정점 i에서 j로 가는 길이가 양수인 경로 여부
 * ______________________________________________________________________
 * <입력 그래프 예시>
 *  0 1 0  |  0→1  |     (0)
 *  0 0 1  |  1→2  |    ↙  ↖ 
 *  1 0 0  |  2→0  |  (1)--→(2)
 * ______________________________________________________________________
 * 노드(0)->(1): direct
 * 노드(0)->(2): (1)거치고 갈 수 있음
 * 노드(1)->(0): (2)거치고 갈 수 있음
 * 노드(1)->(2): direct
 * 노드(2)->(0): direct
 * 노드(2)->(1): (0)거치고 갈 수 있음
 * 
 * 답: 다 연결됨
 */
// input(int, int matrix):  정점 개수, 인접행렬(그래프 G) 원소
// output(int matrix):  정점 i에서 j로 가는 경로 여부(0 또는 1)를 행렬로 표현
function solution(N, matrix) {
    // 플로이드 워셜 알고리즘
    for (let k = 0; k < N; k++) {
        for (let i = 0; i < N; i++) {
            for (let j = 0; j < N; j++) {
                if (matrix[i][k] && matrix[k][j]) {
                    matrix[i][j] = 1;
                }
            }
        }
    }

    // 결과 출력: 한 행씩
    // console.log(matrix); 이렇게 출력하면 다음과 같이 출력됨 -> [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ]
    for (let row of matrix) {
        console.log(row.join(' '));
    }
}


// 입력
const input = require('fs').readFileSync('/dev/stdin').toString().trim().split('\n');

let idx = 0;

// 첫째 줄에서 입력한 값 (정수 1개: 정점 개수 N)
const N = parseInt(input[idx++]);

let matrix = [];

// 정점 N만큼 반복
for (let i = 0; i < N; i++) {   // 행
    // i행 전체 줄 (i행, 모든 j열) elements(값) 입력
    matrix.push(input[idx++].split(' ').map(Number));
}

// 출력
solution(N, matrix);